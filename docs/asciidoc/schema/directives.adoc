[[schema-directives]]
= Directives

== `@cypher`
GraphQL schema directive that can be used to bind a GraphQL field to the results of a Cypher query. 

=== `@cypher` directive on Field

Below we add a field `similarMovies` to our Movie, which is bound to a Cypher query, to find other movies with an overlap of actors;

[source, graphql]
----
type Actor {
    actorId: ID!
    name: String
    movies: [Movie] @relationship(type: "ACTED_IN", direction: "OUT")
}

type Movie {
    movieId: ID!
    title: String
    description: String
    year: Int
    actors(limit: Int = 10): [Actor]
        @relationship(type: "ACTED_IN", direction: "IN")
    similarMovies(limit: Int = 10): [Movie]
        @cypher(
            statement: """
            MATCH (this)<-[:ACTED_IN]-(:Actor)-[:ACTED_IN]->(rec:Movie)
            WITH rec, COUNT(*) AS score ORDER BY score DESC
            RETURN rec LIMIT $limit
            """
        )
}
----

=== `@cypher` statement globals
Global variables available inside the @cypher statement.

1. `this` - bound to the currently resolved node
2. `auth` - See below


==== Auth global

[source, typescript]
----
interface Auth {
    isAuthenticated: boolean;
    roles?: string[];
    jwt: any;
}
----

=== `@cypher` directive on Query

[source, graphql]
----
type Actor {
    actorId: ID!
    name: String
}

type Query {
    allActors: [Actor]
        @cypher(
            statement: """
            MATCH (a:Actor)
            RETURN a
            """
        )
}
----

=== `@cypher` directive on Mutation

[source, graphql]
----
type Actor {
    actorId: ID!
    name: String
}

type Mutation {
    createActor(name: String!): Actor
        @cypher(
            statement: """
            CREATE (a:Actor {name: $name})
            RETURN a
            """
        )
}
----


=== Returning from the `@cypher` statement
You should return a single value representing corresponding type.

==== Primitives

[source, graphql]
----
type Query {
    randomNumber: Int @cypher(statement: "RETURN rand()")
}
----


==== Nodes

[source, graphql]
----
type Query {
    users: [User]
        @cypher(
            statement: """
            MATCH (u:User)
            RETURN u
            """
        )
}
----


==== Objects

[source, graphql]
----
type User {
    id
}

type Query {
    users: [User] @cypher(statement: """
        MATCH (u:User)
        RETURN {
            id: u.id
        }
    """)
}
----

== `@relationship`
See <<schema-basics>>

== `@exclude`
This directive can be used to tell `Neo4jGraphQL` to skip the automatic generation of the Query or Mutations for a certain type.

=== `operations`
1. `create`
2. `delete`
3. `update`
4. `delete`


=== Usage

==== Disable Query Generation

[source, graphql]
----
type User @exclude(operations: ["read"]) {
    name: String
}
----

==== Disable Mutation Generation

[source, graphql]
----
type User @exclude(operations: ["create"]) {
    name: String
}
----

==== Disable Multiple Mutation Generation

[source, graphql]
----
type User @exclude(operations: ["create", "delete"]) {
    name: String
}
----

==== Disable All Queries And Mutations
[source, graphql]
----
type User @exclude(operations: "*") {
    name: String
}
----

> Exclude will not effect OGM methods.


== `@auth`

See <<auth>>

== `@autogenerate`

=== ID's

If the directive is specified and not provided on create will use the [database to generate a uuid](https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-randomuuid).

[source, graphql]
----
type User {
    id: ID! @autogenerate
    username: String!
}
----


=== Timestamps

If you place the directive on a `DateTime` it will, on specified operations, append a [datetime](https://neo4j.com/docs/cypher-manual/current/functions/temporal/#functions-datetime) property to the node.

[source, graphql]
----
type User {
    id: ID! @autogenerate
    createdAt: DateTime! @autogenerate(operations: ["create"])
    updatedAt: DateTime! @autogenerate(operations: ["update"])
}
----

== `@private`
The `@private` directive allows you to specify fields that should only be accessible through the <<ogm>>. This is very handy as you can hide fields such as user password to the outside world. Simply put the @private directive on the field you wish to be inaccessible through the exposed API.


=== Definition
[source, graphql]
----
directive @private on FIELD_DEFINITION
----

=== Usage

[source, graphql]
----
type User {
    password: String! @private
}
----

== `@readonly`
The field will only feature in object types for querying, and will not be mutable.

=== Definition

[source, graphql]
----
"""Instructs @neo4j/graphql to only include a field in generated input type for creating, and in the object type within which the directive is applied."""
directive @readonly on FIELD_DEFINITION
----

== `@writeonly`
This field will only feature in input types, and will not be available for querying the object type through a Query or through a Mutation response.

=== Definition

[source, graphql]
----
"""Instructs @neo4j/graphql to only include a field in the generated input types for the object type within which the directive is applied, but exclude it from the object type itself."""
directive @writeonly on FIELD_DEFINITION
----

== `@ignore`
This field will essentially be completely ignored, and will require another way to resolve the field, such as through the use of a custom resolver.

=== Definition

[source, graphql]
----
"""Instructs @neo4j/graphql to completely ignore a field definition, assuming that it will be fully accounted for by custom resolvers."""
directive @ignore on FIELD_DEFINITION
----

== `@default`

When generating the input type for the create mutation, the value specified in this directive will be used as the default value for this field.


=== Definition

[source, graphql]
----
"""Int | Float | String | Boolean | ID | DateTime"""
scalar Scalar

"""Instructs @neo4j/graphql to set the specified value as the default value in the CreateInput type for the object type in which this directive is used."""
directive @default(
    """The default value to use. Must be a scalar type and must match the type of the field with which this directive decorates."""
    value: Scalar!,
) on FIELD_DEFINITION
----


== `@coalesce`

When translating from GraphQL to Cypher, any instances of fields to which this directive is applied will be wrapped in a `coalesce()` function in the WHERE clause (see https://neo4j.com/developer/kb/understanding-non-existent-properties-and-null-values/#_use_coalesce_to_use_a_default_for_a_null_value). This helps to query against non-existent properties in a database, however it is encouraged to populate these properties with meaningful values if this is becoming the norm. This is a very primitive implementation of the function which only takes a static default value as opposed to using another property in a node or a Cypher expression.

=== Definition

[source, graphql]
----
"""Int | Float | String | Boolean | ID | DateTime"""
scalar Scalar

"""Instructs @neo4j/graphql to wrap the property in a coalesce() function during queries, using the single value specified."""
directive @coalesce(
    """The value to use in the coalesce() function. Must be a scalar type and must match the type of the field with which this directive decorates."""
    value: Scalar!,
) on FIELD_DEFINITION
----
