[[type-definitions-unions-and-interfaces]]
= Unions and Interfaces

Unions and interfaces are abstract GraphQL types that enable a schema field to return one of multiple object types.

[[type-definitions-unions-and-interfaces-union-types]]
== Union Types

The Neo4j GraphQL Library supports the use of unions on relationship fields. For example, the following schema defines a `User` type, that has a relationship `HAS_CONTENT`, of type `[Content]`. `Content` is of type `union` representing either a `Blog` or a `Post`.

[source, graphql]
----
union Content = Blog | Post

type Blog {
    title: String
    posts: [Post] @relationship(type: "HAS_POST", direction: OUT)
}

type Post {
    content: String
}

type User {
    name: String
    content: [Content] @relationship(type: "HAS_CONTENT", direction: OUT)
}
----

Below you can find some examples of how queries and mutations work with this example.

=== Querying a union

The Neo4j GraphQL Library only returns union members which have inline fragments in your selection set.

For example, the following will return users and only their blogs:

[source, graphql]
----
query GetUsersWithBlogs {
    users {
        name
        content {
            ... on Blog {
                title
                posts {
                    content
                }
            }
        }
    }
}
----

Whilst the query below will return both the blogs and posts of users:

[source, graphql]
----
query GetUsersWithAllContent {
    users {
        name
        content {
            ... on Blog {
                title
                posts {
                    content
                }
            }
            ... on Post {
                content
            }
        }
    }
}
----

=== Creating a union

The below mutation creates the user and their content:

[source, graphql]
----
mutation CreateUserAndContent {
    createUsers(
        input: [
            {
                name: "Dan"
                content: {
                    Blog: {
                        create: [
                            {
                                node: {
                                    title: "My Cool Blog"
                                    posts: {
                                        create: [
                                            {
                                                node: {
                                                    content: "My Cool Post"
                                                }
                                            }
                                        ]
                                    }
                                }
                            }
                        ]
                    }
                }
            }
        ]
    ) {
        users {
            name
        }
    }
}

----


== Interface Types

Using interface types will give you no database support, therefore there is no support for querying, updating, deleting, filtering. But instead used as a language feature to safeguard your schema. Great for when dealing with repetitive or large schemas you can essentially put "The side railings up".
