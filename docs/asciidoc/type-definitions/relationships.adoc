[[type-definitions-relationships]]
= Relationships

Without relationships, your type definitions are simply a collection of disconnected nodes, with little value. Adding relationships into your data model gives your data the context that it needs to run complex queries across wide sections of your graph. This section will run through writing some type definitions for a simple connected model, inserting some data through the schema, and then querying it.

== Example graph

We will be using the following example graph, where a Person type has two different relationship types which can connect it to a Movie type.

image::relationships.svg[title="Example graph"]

== Type definitions

First, to define the nodes, we should define the two distinct types in this model:

[source, graphql]
----
type Person {
    name: String!
    born: Int!
}

type Movie {
    title: String!
    released: Int!
}
----

We can then connect these two types together using `@relationship` directives:

[source, graphql]
----
type Person {
    name: String!
    born: Int!
    actedInMovies: [Movie!]! @relationship(type: "ACTED_IN", direction: OUT)
    directedMovies: [Movie!]! @relationship(type: "DIRECTED", direction: OUT)
}

type Movie {
    title: String!
    released: Int!
    actors: [Person!]! @relationship(type: "ACTED_IN", direction: IN)
    director: Person! @relationship(type: "DIRECTED", direction: IN)
}
----

The following should be noted about the fields we just added:

* A Person can act in or direct multiple movies, and a Movie can have multiple actors. However, it is exceedingly rare for a Movie to have more than one director, and we can model this cardinality in our type definitions, to ensure accuracy of our data.
* A Movie isn't really a Movie without a director, and we have signified this by marking the `director` field as non-nullable, meaning that a Movie must have a `DIRECTED` relationship coming into it.
* To figure out whether the `direction` argument of the `@relationship` directive should be `IN` or `OUT`, visualise your relationships like in the diagram above, and model out the direction of the arrows.

=== Relationship Properties

Relationship properties can be added to the above type definitions in two steps:

1. Add an interface definition containing the desired relationship properties
2. Add a `properties` argument to both "sides" of the `@relationship` directive which points to the newly defined interface

For example, to distinguish which roles an actor played in a movie:

[source, graphql]
----
type Person {
    name: String!
    born: Int!
    actedInMovies: [Movie!]! @relationship(type: "ACTED_IN", properties: "ActedIn", direction: OUT)
    directedMovies: [Movie!]! @relationship(type: "DIRECTED", direction: OUT)
}

type Movie {
    title: String!
    released: Int!
    actors: [Person!]! @relationship(type: "ACTED_IN", properties: "ActedIn", direction: IN)
    director: Person! @relationship(type: "DIRECTED", direction: IN)
}

interface ActedIn {
    roles: [String!]
}
----

== Inserting data

Nested mutations mean that there are many ways in which we can insert data into our database through the GraphQL schema. We know that we can't create a Movie without adding a director, and we can do that by either creating the director first and then creating and connecting the movie, or we can create both the Movie and the director in the same mutation. Let's try the latter:

[source, graphql]
----
mutation CreateMovieAndDirector {
    createMovies(input: [
        {
            title: "Forrest Gump"
            released: 1994
            director: {
                create: {
                    node: {
                        name: "Robert Zemeckis"
                        born: 1951s
                    }
                }
            }
        }
    ]) {
        movies {
            title
            released
            director {
                name
                born
            }
        }
    }
}
----

We then need to create the actor in our example, and connect them to the new Movie node, also specifying which roles they played:

[source, graphql]
----
mutation CreateActor {
    createActors(input: [
        {
            name: "Tom Hanks"
            born: 1956
            movies: {
                connect: {
                    where: {
                        node: { title: "Forrest Gump" }
                    }
                    properties: {
                        roles: ["Forrest"]
                    }
                }
            }
        }
    ]) {
        movies {
            title
            released
            director {
                name
                born
            }
            actorsConnection {
                edges {
                    roles
                    node {
                        name
                        born
                    }
                }
            }
        }
    }
}
----

Note that we select the `actorsConnection` field in order to query the `roles` relationship property.

As you can see, these nested mutations are very powerful, and in the second Mutation we ran, we were able to return the entire graph which was created in this example. In fact, these mutations can actually be compressed down into a single Mutation which inserts all of the data we need:

[source, graphql]
----
mutation CreateMovieDirectorAndActor {
    createMovies(input: [
        {
            title: "Forrest Gump"
            released: 1994
            director: {
                create: {
                    node: {
                        name: "Robert Zemeckis"
                        born: 1951
                    }
                }
            }
            actors: {
                create: [
                    {
                        node: {
                            name: "Tom Hanks"
                            born: 1956
                        }
                        properties: {
                            roles: ["Forrest"]
                        }
                    }
                ]
            }
        }
    ]) {
        movies {
            title
            released
            director {
                name
                born
            }
            actorsConnection {
                edges {
                    roles
                    node {
                        name
                        born
                    }
                }
            }
        }
    }
}
----

Once you get your head around this, you'll be creating giant sub-graphs in one Mutation in no time!

== Fetching our data

Now that we have our Movie information in the database, we can query all of the information which just inserted as follows:

[source, graphql]
----
query {
    movies(where: { title: "Forrest Gump" }) {
        title
        released
        director {
            name
            born
        }
        actorsConnection {
            edges {
                roles
                node {
                    name
                    born
                }
            }
        }
    }
}
----
