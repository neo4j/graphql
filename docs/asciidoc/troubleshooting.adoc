[[troubleshooting]]
= Troubleshooting

== Debug Logging

`@neo4j/graphql` uses the https://www.npmjs.com/package/debug[`debug`] library for debug-level logging. You can turn on all debug logging by setting the environment variable `DEBUG` to `@neo4j/graphql:*` whilst running. For example:

[source, bash]
----
DEBUG=@neo4j/graphql:* node src/index.js
----

Alternatively, if you are debugging a particular functionality, you can specify a number of namespaces to isolate certain log lines:

1. `@neo4j/graphql:*` - Logs all
2. `@neo4j/graphql:auth` - Logs the status of authorization header and token extraction, and decoding of JWT
3. `@neo4j/graphql:graphql` - Logs the GraphQL query and variables
4. `@neo4j/graphql:execute` - Logs the Cypher and Cypher paramaters before execution, and summary of execution

== Query Tuning

Hopefully you won't need to perform any query tuning, but if you do, the Neo4j GraphQL Library allows you to set the full array of query options on construction of the library.

You can read more about the available query options at https://neo4j.com/docs/cypher-manual/current/query-tuning/query-options/#cypher-query-options.

_Please only set these options if you know what you are doing._

For example, in order to set the Cypher runtime to "interpreted":

[source, javascript]
----
const { Neo4jGraphQL, CypherRuntime } = require("@neo4j/graphql");
const neo4j = require("neo4j-driver");
const { ApolloServer } = require("apollo-server");

const typeDefs = `
    type Movie {
        title: String!
    }
`;

const driver = neo4j.driver(
    "bolt://localhost:7687",
    neo4j.auth.basic("neo4j", "password")
);

const neoSchema = new Neo4jGraphQL({
    typeDefs,
    driver,
    config: {
        queryOptions: {
            runtime: CypherRuntime.INTERPRETED,
        },
    },
});

const server = new ApolloServer({
    schema: neoSchema.schema,
    context: ({ req }) => ({ req }),
});

server.listen().then(({ url }) => {
  console.log(`Server ready at ${url}`);
});
----

== I've upgraded from <1.1.0 and my `DateTime` fields aren't sorting as expected!

Due to a bug in versions less than 1.1.0, there is a chance that your `DateTime` fields are stored in the database as strings instead of temporal values. You should perform a rewrite of those properties in your database using a Cypher query. For an example where the affected node has label "Movie" and the affected property is "timestamp", you can do this using the following Cypher:

[source, javascript]
----
MATCH (m:Movie)
WHERE apoc.meta.type(m.timestamp) = "STRING"
SET m.timestamp = datetime(m.timestamp)
RETURN m
----
