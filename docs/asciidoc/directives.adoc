[[directives]]
= Directives

== `@cypher`
GraphQL schema directive that can be used to bind a GraphQL field to the results of a Cypher query.

=== `@cypher` directive on Field

Below we add a field `similarMovies` to our Movie, which is bound to a Cypher query, to find other movies with an overlap of actors;

[source, graphql]
----
type Actor {
    actorId: ID!
    name: String
    movies: [Movie] @relationship(type: "ACTED_IN", direction: OUT)
}

type Movie {
    movieId: ID!
    title: String
    description: String
    year: Int
    actors(limit: Int = 10): [Actor]
        @relationship(type: "ACTED_IN", direction: IN)
    similarMovies(limit: Int = 10): [Movie]
        @cypher(
            statement: """
            MATCH (this)<-[:ACTED_IN]-(:Actor)-[:ACTED_IN]->(rec:Movie)
            WITH rec, COUNT(*) AS score ORDER BY score DESC
            RETURN rec LIMIT $limit
            """
        )
}
----

=== `@cypher` statement globals
Global variables available inside the @cypher statement.

1. `this` - bound to the currently resolved node
2. `auth` - See below


==== Auth global

[source, typescript]
----
interface Auth {
    isAuthenticated: boolean;
    roles?: string[];
    jwt: any;
}
----

=== `@cypher` directive on Query

[source, graphql]
----
type Actor {
    actorId: ID!
    name: String
}

type Query {
    allActors: [Actor]
        @cypher(
            statement: """
            MATCH (a:Actor)
            RETURN a
            """
        )
}
----

=== `@cypher` directive on Mutation

[source, graphql]
----
type Actor {
    actorId: ID!
    name: String
}

type Mutation {
    createActor(name: String!): Actor
        @cypher(
            statement: """
            CREATE (a:Actor {name: $name})
            RETURN a
            """
        )
}
----


=== Returning from the `@cypher` statement
You should return a single value representing corresponding type.

==== Primitives

[source, graphql]
----
type Query {
    randomNumber: Int @cypher(statement: "RETURN rand()")
}
----


==== Nodes

[source, graphql]
----
type Query {
    users: [User]
        @cypher(
            statement: """
            MATCH (u:User)
            RETURN u
            """
        )
}
----


==== Objects

[source, graphql]
----
type User {
    id
}

type Query {
    users: [User] @cypher(statement: """
        MATCH (u:User)
        RETURN {
            id: u.id
        }
    """)
}
----

== `@relationship`
See <<schema-basics>>

== `@exclude`
This directive can be used to tell `Neo4jGraphQL` to skip the automatic generation of the Query or Mutations for a certain type.

=== `operations`
1. CREATE
2. READ
3. UPDATE
4. DELETE


=== Usage

==== Disable Query Generation

[source, graphql]
----
type User @exclude(operations: [READ]) {
    name: String
}
----

==== Disable Mutation Generation

[source, graphql]
----
type User @exclude(operations: [CREATE]) {
    name: String
}
----

==== Disable Multiple Mutation Generation

[source, graphql]
----
type User @exclude(operations: [CREATE, DELETE]) {
    name: String
}
----

==== Disable All Queries And Mutations
[source, graphql]
----
type User @exclude {
    name: String
}
----

> Exclude will not effect OGM methods.


== `@auth`

See <<auth>>

== `@id`
If the directive is specified and not provided on create will use the [database to generate a uuid](https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-randomuuid).

[source, graphql]
----
type User {
    id: ID! @id(autogenerate: true)
    username: String!
}
----

=== Definition

[source, graphql]
----
"""Indicates that the field is the unique identifier for the object type, and additionally enables the autogeneration of IDs."""
directive @id(autogenerate: Boolean! = false) on FIELD_DEFINITION
----

== `@timestamp`
If you place this directive on a `DateTime` it will, on specified operations, append a [datetime](https://neo4j.com/docs/cypher-manual/current/functions/temporal/#functions-datetime) property to the node.

[source, graphql]
----
type User {
    createdAt: DateTime! @timestamp(operations: [CREATE])
    updatedAt: DateTime! @timestamp(operations: [UPDATE])
}
----

=== Definition

[source, graphql]
----
enum TimestampOperation {
    CREATE
    UPDATE
}

"""Instructs @neo4j/graphql to generate timestamps on particular events, which will be available as the value of the specified field."""
directive @timestamp(
    """Which events to generate timestamps on. Defaults to both create and update."""
    operations: [TimestampOperation]! = [CREATE, UPDATE]
) on FIELD_DEFINITION
----

== `@private`
The `@private` directive allows you to specify fields that should only be accessible through the <<ogm>>. This is very handy as you can hide fields such as user password to the outside world. Simply put the @private directive on the field you wish to be inaccessible through the exposed API.


=== Definition
[source, graphql]
----
directive @private on FIELD_DEFINITION
----

=== Usage

[source, graphql]
----
type User {
    password: String! @private
}
----

== `@readonly`
The field will only feature in object types for querying, and will not be mutable.

=== Definition

[source, graphql]
----
"""Instructs @neo4j/graphql to only include a field in generated input type for creating, and in the object type within which the directive is applied."""
directive @readonly on FIELD_DEFINITION
----

== `@writeonly`
This field will only feature in input types, and will not be available for querying the object type through a Query or through a Mutation response.

=== Definition

[source, graphql]
----
"""Instructs @neo4j/graphql to only include a field in the generated input types for the object type within which the directive is applied, but exclude it from the object type itself."""
directive @writeonly on FIELD_DEFINITION
----

== `@ignore`
This field will essentially be completely ignored, and will require another way to resolve the field, such as through the use of a custom resolver.

=== Definition

[source, graphql]
----
"""Instructs @neo4j/graphql to completely ignore a field definition, assuming that it will be fully accounted for by custom resolvers."""
directive @ignore on FIELD_DEFINITION
----

== `@default`

When generating the input type for the create mutation, the value specified in this directive will be used as the default value for this field.

Reference: <<type-definitions-default-values-default>>


== `@coalesce`

When translating from GraphQL to Cypher, any instances of fields to which this directive is applied will be wrapped in a `coalesce()` function in the WHERE clause (see https://neo4j.com/developer/kb/understanding-non-existent-properties-and-null-values/#_use_coalesce_to_use_a_default_for_a_null_value). This helps to query against non-existent properties in a database, however it is encouraged to populate these properties with meaningful values if this is becoming the norm. This is a very primitive implementation of the function which only takes a static default value as opposed to using another property in a node or a Cypher expression.

Reference: <<type-definitions-default-values-coalesce>>
