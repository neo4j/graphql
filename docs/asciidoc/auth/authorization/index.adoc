[[auth-authorization]]
= Authrization

You specify authorization rules inside the `@auth` directive, this section looks at each argument & explains how to use to secure your GraphQL API.

== `rules`

You can have many rules for many operations. We fallthrough each rule, on the corresponding operation, until a match. On no match, an error is thrown. You can think of rules as a big OR.

[source, graphql]
----
@auth(rules: [
    { operations: ["create", "update"], ... }, ## or
    { operations: ["read", "update"], ...}, ## or
    { operations: ["delete", "update"], ... } ## or
])
----

== `operations`

Operations is an array, you can re-use the same rule for many operations.

[source, graphql]
----
@auth(rules: [
    { operations: ["create", "update", "delete", "connect", "disconnect"] },
    { operations: ["read"] }
])
----

> You can use `operations: "*" to denote all operations

Many different operations can be called in one query take the below mutation;

[source, graphql]
----
mutation {
    createPosts(
        input: [
            {
                content: "I like GraphQL",
                creator: { connect: { where: { id: "user-01" } } }
            }
        ]
    ) {
        posts {
            content
        }
    }
}
----

In the above example; First we do a `create` operation then we do a `connect` operation.

The full list of operations are;

1. read - `MATCH`
2. create - `CREATE`
3. update - `SET`
4. delete - `DELETE`
5. connect - `MATCH` & `MERGE`
6. disconnect - `MATCH` & `DELETE`

== `isAuthenticated`

This is the most basic of auth. Used to ensure that there is a valid decoded JWT in the request. The most basic of applications could look something like this;

[source, graphql]
----
type Todo {
    id: ID
    title: String
}

extend type Todo @auth(rules: [{ operations: "*", isAuthenticated: true }])
----

== `roles`

Use the roles property to specify the allowed roles for an operation. Use ENV `JWT_ROLES_OBJECT_PATH` to specify a object path for JWT roles otherwise defaults to `jwt.roles`

[source, graphql]
----
type User {
    id: ID
    name: String
}

extend type User @auth(rules: [{ operations: ["update"], roles: ["admin"] }])
----

Above showing an admin role is required for all operations against Users. If you have multiple roles you can add more items to the array;

[source, graphql]
----
extend type User @auth(rules: [{ operations: "*", roles: ["admin", "super-admin"] }])
----


> Users only need one of many roles to satisfy a rule.

== `allow`

Use allow to ensure, on matched nodes, a connection exists between a value on the JWT vs a property on each matched node. Taking a closer, look let's put two users in a hypothetical empty database;

[source, cypher]
----
CREATE (:User {id:"user1", name: "one"}), (:User {id:"user2", name: "two"})
----

[source, graphql]
----
type User {
    id: ID!
    name: String!
}
----

Now we have two users in our database, and given the above GraphQL type definitions - How can we restrict `user1` from seeing `user2`? This is where allow comes in;

[source, graphql]
----
type User {
    id: ID!
    name: String!
}

extend type User @auth(
    rules: [
        {
            operations: ["read"],
            allow: { id: "$jwt.sub" }
        }
    ]
)
----

After we match the node we validate that the property on the node is equal to the `jwt.sub` property. This validation is done in Cypher with two functions; validatePredicate & validate.

Given `user1` has the decoded JWT;
[source, json]
----
{
  "sub": "user1",
  "iat": 1516239022
}
----

With this JWT makes a GraphQL query to get `user2`;
[source, graphql]
----
query {
    users(where: { id: "user2" }) {
        name
    }
}
----

The generated cypher for this query would look like the below and throw you out the operation.

[source, cypher]
----
MATCH (u:User {id: "user2"})
CALL apoc.util.validate(NOT(u.id = "user1"), "Forbidden")
RETURN u
----

Allow is used on the following operations;

1. read
2. update
3. connect
4. disconnect
5. delete

=== `allow` Across Relationships

There may be a reason where you need to traverse across relationships to satisfy your Auth implementation. One example of this could be "Grant update access to all Moderators of a Post";

[source, graphql]
----
type User {
    id: ID
    name: String
}

type Post {
    content: String
    moderators: [User] @relationship(type: "MODERATES_POST", direction: IN)
}

extend type Post @auth(rules: [
    { operations: ["update"], allow: { moderators: { id: "$jwt.sub" } } }
])
----

When you specify allow on a relationship you can select fields on the referenced node. It's worth pointing out that allow on a relationship will perform an `ANY` on the matched nodes; to see if there is a match.

Given the above example - There may be a time when you need to give update access to either the creator of a post or a moderator, you can use `OR` and `AND` inside allow;

[source, graphql]
----
type User {
    id: ID
    name: String
}

type Post {
    content: String
    moderators: [User] @relationship(type: "MODERATES_POST", direction: IN)
    creator: User @relationship(type: "HAS_POST", direction: IN)
}

extend type Post
    @auth(
        rules: [
            {
                operations: ["update"],
                allow: { OR: [{ moderators: { id: "$jwt.sub" } }, { creator: { id: "$jwt.sub" } }] }
            }
        ]
    )
----

=== Field Level `allow`

Allow works the same as it does on Type Definitions although its context is the Field. So instead of enforcing auth rules when the node is matched and or upserted, it would instead; be called when the Field is selected or upserted. Given the following, it is hiding the password to only the user themselves;

[source, graphql]
----
type User {
    id: ID!
    name: String!
    password: String! @auth(rules: [{ operations: "*", allow: { id: "$jwt.sub" } }])
}
----

== `where`
Use the `where` argument, on Node definitions, to conceptually append predicates to the Cypher `WHERE` clause. Given the current user ID is "123" and the following the schema;

[source, graphql]
----
type User {
    id: ID
    name: String
}

extend type User @auth(rules: [{ operations: "*", where: { id: "$jwt.id" } }])
----

Then issues a GraphQL query for users;

[source, graphql]
----
query {
    users {
        id
        name
    }
}
----

Behind the scenes the userâ€™s ID is **conceptually** prepended to the query;

[source, graphql]
----
query {
    users(where: { id: "123" }){
        id
        name
    }
}
----

Where is used on the following operations;

1. read
2. update
3. connect
4. disconnect
5. delete


== `bind`

Use bind to ensure, on creating or updating nodes, a connection exists between a value on the JWT vs a property on a matched node. This validation is done after the operation but inside a transaction. Taking a closer, look let's put a user in our database;

[source, cypher]
----
CREATE (:User {id:"user1", name: "one"})
----

[source, graphql]
----
type User {
    id: ID!
    name: String!
}
----


Given the above GraphQL type definitions - How can we restrict `user1` from changing there id ?

[source, graphql]
----
type User {
    id: ID!
    name: String!
}

extend type User @auth(
    rules: [
        {
            operations: ["update"],
            bind: { id: "$jwt.sub" }
        }
    ]
)
----

After we update or create the node we validate that the property on the node is equal to the `JWT.sub` property. This validation is done in Cypher with function `apoc.util.validate`

Given `user1` has the decoded JWT;

[source, json]
----
{
  "sub": "user1",
  "iat": 1516239022
}
----

With this JWT makes a GraphQL mutation to update there id to someone else;


[source, graphql]
----
mutation {
    updateUsers(where: { id: "user1" }, update: { id: "user2" }) {
        users {
            name
        }
    }
}
----

The generated cypher for this query would look like the below, Throwing us out of the operation because the ids do not match.


[source, cypher]
----
MATCH (u:User {id: "user1"})
SET u.id = "user2"
CALL apoc.util.validate(NOT(u.id = "user1"), "Forbidden")
RETURN u
----


Bind is used on the following operations;

1. create
2. update
3. connect
4. disconnect
5. delete


=== `bind` Across Relationships

There may be a reason where you need to traverse across relationships to satisfy your Auth implementation. One example of this could be "Ensure that users only create Posts related to themselves";

[source, graphql]
----
type User {
    id: ID
    name: String
}

type Post {
    content: String
    creator: User @relationship(type: "HAS_POST", direction: IN)
}

extend type Post @auth(rules: [
    { operations: ["create"], bind: { creator: { id: "$jwt.sub" } } }
])
----

When you specify `bind` on a relationship you can select fields on the referenced node. It's worth pointing out that allow on a relationship will perform an `ALL` on the matched nodes; to see if there is a match. This means you can only use `bind` to enforce a single relationship to a single node.

=== Field Level `bind`

You can use bind on a field. The root is still considered the node. Taking the example at the start of this `bind` section; you could do the following;

[source, graphql]
----
type User {
    id: ID! @auth(rules: [{ operations: ["update"], bind: { id: "$jwt.sub" } }])
    name: String!
}
----