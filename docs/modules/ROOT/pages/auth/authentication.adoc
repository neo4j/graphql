[[auth-authentication]]
= Authentication

The Neo4j GraphQL Library expects an `authorization` header in the request object, which means you can authenticate users however you like. You could have a custom sign-in mutation, integrate with Auth0, or roll your own SSO server. The point here is that it’s just a JWT which the library decodes to make sure it’s valid - but it’s down to the user to issue tokens.

> The example at xref::ogm/examples/custom-resolvers.adoc[Custom Resolvers] demonstrates a hypothetical sign-up/sign-in flow using the xref::ogm/index.adoc[OGM], which will be a good starting point for inspiration.

== `isAuthenticated`

This is the most basic of authentication, used to ensure that there is a valid decoded JWT in the request. The most basic of type definitions could look something like the following, which states you must be authenticated to access `Todo` objects:

[source, graphql, indent=0]
----
type Todo {
    id: ID
    title: String
}

extend type Todo @auth(rules: [{ isAuthenticated: true }])
----

== `allowUnauthenticated`

In some cases, you may want to allow unauthenticated requests while also having auth-based rules. You can use the `allowUnauthenticated` parameter to avoid throwing an exception if no auth is present in the context.

In the example below, only the publisher can see his blog posts if it is not published yet. Once the blog post is published, anyone can see it:

[source, graphql, indent=0]
----
type BlogPost
    @auth(
        rules: [
            {
                operations: [READ]
                where: { OR: [{ publisher: "$jwt.sub" }, { published: true }] }
                allowUnauthenticated: true
            }
        ]
    ) {
    id: ID!
    publisher: String!
    published: Boolean!
}
----

[[auth-global-authentication]]
== Global Authentication

For some cases the GraphQL API needs to be secured globally to restrict access to _any_ of the top-level GraphQL types without prior authentication. In the Neo4j GraphQL Library this is referred to as global authentication. It is also known as API-wide authorization. 

=== Configuration

To use the global authentication functionality, it is required to have an instance of an auth plugin for the Neo4j GraphQL Library. For most use cases you will only need to use our provided plugins at `@neo4j/graphql-plugin-auth`. Below is an example configuration enabling global authentication via the `Neo4jGraphQLAuthJWTPlugin` class:

[source, javascript, indent=0]
----
import { Neo4jGraphQL } from "@neo4j/graphql";
import { Neo4jGraphQLAuthJWTPlugin } from "@neo4j/graphql-plugin-auth";

const neoSchema = new Neo4jGraphQL({
    typeDefs,
    plugins: {
        auth: new Neo4jGraphQLAuthJWTPlugin({
            secret: "super-secret",
            globalAuthentication: true,
        })
    }
});
----

NOTE: Observe that the `Neo4jGraphQLAuthJWTPlugin` class does not accept to enable both `noVerify` and `globalAuthentication` simultaneously.

If you would like to use JWKS decoding and enable global authentication then use the `Neo4jGraphQLAuthJWKSPlugin` class like so:

[source, javascript, indent=0]
----
import { Neo4jGraphQL } from "@neo4j/graphql";
import { Neo4jGraphQLAuthJWKSPlugin } from "@neo4j/graphql-plugin-auth";

const neoSchema = new Neo4jGraphQL({
    typeDefs,
    plugins: {
        auth: new Neo4jGraphQLAuthJWKSPlugin({
            jwksEndpoint: "https://YOUR_DOMAIN/well-known/jwks.json",
            globalAuthentication: true,
        })
    }
});
----

=== Functionality

If global authentication is enabled in the auth plugin for the Neo4j GraphQL Library, it is required that _each_ request contains a valid JWT token in the `authorization` header. Otherwise an authentication error will be thrown.

