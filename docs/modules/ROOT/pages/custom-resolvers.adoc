[[custom-resolvers]]
= Custom Resolvers

The library will autogenerate Query and Mutation resolvers, so you donâ€™t need to implement those resolvers yourself. However, if you would like additional behaviours besides the autogenerated CRUD operations, you can specify custom resolvers for these scenarios.

== Custom object type field resolver

[[custom-resolver-directive]]
=== `@customResolver`

If you would like to add a field to an object type which is resolved from existing values in the type, rather than storing new values, you should mark it with the `@customResolver` directive (see below) and define a custom resolver for it. Take for instance a simple schema:

[source, javascript, indent=0]
----
const typeDefs = `
    type User {
        firstName: String!
        lastName: String!
        fullName: String! @customResolver(requires: "firstName lastName")
    }
`;

const resolvers = {
    User: {
        fullName(source) {
            return `${source.firstName} ${source.lastName}`;
        },
    },
};

const neoSchema = new Neo4jGraphQL({
    typeDefs,
    resolvers,
});
----

Here `fullName` is a value that is resolved from the fields `firstName` and `lastName`. Specifying the `@customResolver` directive on the field definition keeps `fullName` from being included in any `Query` or `Mutation` fields and hence as a property on the `:User` node in the database.

The inclusion of the fields `firstName` and `lastName` in the `requires` argument means that in the definition of the resolver, the properties `firstName` and `lastName` will always be defined on the `source` object. If these fields are not specified, this cannot be guaranteed.

==== Definition

[source, graphql, indent=0]
----
"""Informs @neo4j/graphql that a field will be resolved by a custom resolver, and allows specification of any field dependencies."""
directive @customResolver(
    """Fields that the custom resolver will depend on."""
    requires: [String!]
) on FIELD_DEFINITION
----

==== The `requires` argument

Any fields that the custom resolver depends on should be passed to the `requires` argument to ensure that during the Cypher generation process those properties are selected from the database.

Any field can be required, as long as it is not another `@customResolver` field.

The `requires` argument accepts a selection set string. Using a selection set string makes it possible to select fields from related types as below:

[source, javascript, indent=0]
----
const typeDefs = `
    type Address {
        houseNumber: Int!
        street: String!
        city: String!
    }

    type User {
        id: ID!
        firstName: String!
        lastName: String!
        address: Address! @relationship(type: "LIVES_AT", direction: OUT)
        fullName: String
            @customResolver(requires: "firstName lastName address { city street }")
    }
`;

const resolvers = {
    User: {
        fullName({ firstName, lastName, address }) {
            return `${firstName} ${lastName} from ${address.street} in ${address.city}`;
        },
    },
};

const neoSchema = new Neo4jGraphQL({
    typeDefs,
    resolvers,
});
----

In this example, the `firstName`, `lastName`, `address.street` and `address.city` fields will always be selected from the database if the `fullName` field is selected and will be available to the custom resolver.

It is also possible to inline fragments to conditionally select fields from interface/union types:

[source, graphql, indent=0]
----
interface Publication {
    publicationYear: Int!
}

type Author {
    name: String!
    publications: [Publication!]! @relationship(type: "WROTE", direction: OUT)
    publicationsWithAuthor: [String!]!
        @customResolver(
            requires: "name publications { publicationYear ...on Book { title } ... on Journal { subject } }"
        )
}

type Book implements Publication {
    title: String!
    publicationYear: Int!
    author: [Author!]! @relationship(type: "WROTE", direction: IN)
}

type Journal implements Publication {
    subject: String!
    publicationYear: Int!
    author: [Author!]! @relationship(type: "WROTE", direction: IN)
}
----

It is **not** possible to require extra fields generated by the library such as aggregations and connections.
For example, the type definitions below would throw an error as they attempt to require the `publicationsAggregate`:

[source, graphql, indent=0]
----
interface Publication {
    publicationYear: Int!
}

type Author {
    name: String!
    publications: [Publication!]! @relationship(type: "WROTE", direction: OUT)
    publicationsWithAuthor: [String!]!
        @customResolver(
            requires: "name publicationsAggregate { count }"
        )
}

type Book implements Publication {
    title: String!
    publicationYear: Int!
    author: [Author!]! @relationship(type: "WROTE", direction: IN)
}

type Journal implements Publication {
    subject: String!
    publicationYear: Int!
    author: [Author!]! @relationship(type: "WROTE", direction: IN)
}
----

==== Providing custom resolvers

Note that any field marked with the `@customResolver` directive, requires a custom resolver to be defined.
If the directive is marked on an interface, any implementation of that interface requires a custom resolver to be defined.
Take for example this schema:

[source, graphql, indent=0]
----
interface UserInterface {
    fullName: String! @customResolver
}

type User implements UserInterface {
    id: ID!
    fullName: String!
}
----

The following resolvers definition would be invalid:

[source, javascript, indent=0]
----
const resolvers = {
    UserInterface: {
        fullName() {
            return "Hello World!";
        },
    },
};
----

Instead, the following resolvers definition would be required:
[source, javascript, indent=0]
----
const resolvers = {
    User: {
        fullName() {
            return "Hello World!";
        },
    },
};
----

These checks may not always be required or desirable. If this is the case, they can be disabled using the `startupValidation` config option:

[source, javascript, indent=0]
----
const neoSchema = new Neo4jGraphQL({
    typeDefs,
    config: {
        startupValidation: {
          resolvers: false
        },
    },
})
----