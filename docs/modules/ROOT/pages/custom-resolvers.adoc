[[custom-resolvers]]
= Custom Resolvers

The library will autogenerate Query and Mutation resolvers, so you donâ€™t need to implement those resolvers yourself. However, if you would like additional behaviours besides the autogenerated CRUD operations, you can specify custom resolvers for these scenarios.

== Custom object type field resolver

If you would like to add a field to an object type which is resolved from existing values in the type, rather than storing new values, you should mark it with an xref::type-definitions/access-control.adoc#type-definitions-access-control-ignore[`@ignore`] directive and define a custom resolver for it. Any fields that the source object in the custom resolver depends on must be included in the array passed to the `dependsOn` argument. This is to ensure that during the Cypher generation process the required fields will be fetched from the database. Take for instance a simple schema:

[source, javascript, indent=0]
----
const typeDefs = `
    type User {
        firstName: String!
        lastName: String!
        fullName: String! @ignore(dependsOn: ["firstName", "lastName"])
    }
`;

const resolvers = {
    User: {
        fullName(source) {
            return `${source.firstName} ${source.lastName}`;
        },
    },
};

const neoSchema = new Neo4jGraphQL({
    typeDefs,
    resolvers,
});
----

Here `fullName` is a computed value from the fields `firstName` and `lastName`. Specifying the `@ignore` directive on the field definition keeps `fullName` from being included in any `Query` or `Mutation` fields and hence as a property on the `:User` node in the database.

The inclusion of the fields `firstName` and `lastName` in the `dependsOn` argument means that in the definition of the resolver the properties `firstName` and `lastName` will always be defined on the `source` object. If these fields are not specified, this cannot be guaranteed.

== Custom Query/Mutation type field resolver

You can define additional custom Query and Mutation fields in your type definitions and provide custom resolvers for them. A prime use case for this is using the xref::ogm/index.adoc[OGM] to manipulate types and fields which are not available through the API. You can find an example of it being used in this capacity in the xref::ogm/examples/custom-resolvers.adoc[Custom Resolvers] example.
