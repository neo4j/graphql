[[type-definitions-database-mapping]]
= Database Mapping

[[type-definitions-alias]]
== `@alias`

This directive maps a GraphQL field to a Neo4j property on a node or
relationship.

This can be used on any fields that are not `@cypher` or `@relationship` fields.

=== Definition

[source, graphql, indent=0]
----
"""Indicates that the field is to be mapped to the underlying Neo4j under a different property name."""
directive @alias(property: String!) on FIELD_DEFINITION
----

=== Usage

[source, graphql, indent=0]
----
type User {
    id: ID! @id @alias(property: "dbId")
    username: String!
}
----

[source, graphql, indent=0]
----
type User {
    id: ID! @id
    username: String! @alias(property: "dbUserName")
    livesIn: [City] @relationship(direction: OUT, type: "LIVES_IN", properties: "UserLivesInProperties")
}

type City {
    name: String
}

interface UserLivesInProperties @relationshipProperties {
    since: DateTime @alias(property: "moveInDate")
}
----

[[type-definitions-node]]
== `@node`

The `@node` directive maps a GraphQL type to one or more Neo4j labels.

=== Definition

[source, graphql, indent=0]
----
"""Indicates that the type is will be mapped to the underlying Neo4j label."""
directive @node(label: String, additionalLabels: [String]) on OBJECT
----

=== Usage
`@node` can be used with the optional parameters `label` and `additionalLabels`.

==== Label
The parameter `label` defines the label to be used in Neo4j instead of the GraphQL type:

[source, graphql, indent=0]
----
type Movie @node(label="Film") {
    title: String!
}
----

This way, the following query:

[source, graphql, indent=0]
----
{
  movies {
    title
  }
}
----

Generates the cypher query:

[source, cypher, indent=0]
----
MATCH (this:Film)
RETURN this { .title } as this
----

==== AdditionalLabels

AdditionalLabels lets you define extra Neo4j labels that need to exist in the node for that GraphQL type.

[source, graphql, indent=0]
----
type Actor @node(additionalLabels=["Person", "User"]) {
    name: String!
}
----

The following query:

[source, graphql, indent=0]
----
{
  Actor {
    name
  }
}
----

Generates the following cypher query, with the labels `Actor`, `Person` and `User`:

[source, cypher, indent=0]
----
MATCH (this:Actor:Person:User)
RETURN this { .name } as this
----

Note that both parameters can be used at the same time:

[source, graphql, indent=0]
----
type Actor @node(label="ActorDB", additionalLabels=["Person"]) {
    name: String!
}
----

In this case, the resulting Cypher query will use the labels `ActorDB` and `Person` instead of `Actor`:

----
MATCH (this:ActorDB:Person)
RETURN this { .name } as this
----
