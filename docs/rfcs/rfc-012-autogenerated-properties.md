# Autogenerated Properties

## Problem
We want to allow for node properties to be generated automatically, via code, when creating (and possibly updating) nodes. 
This would solve common problems such as custom ids or creation of slugs.

Related Issue: [627](https://github.com/neo4j/graphql/issues/627)

## Proposed Solution
The proposed solutions would add a new directive `@callback` an a new config option to `Neo4jGraphQL` (`callbacks`). This directive will mark some properties
to be autogenerated by a callback function, passed to `Neo4jGraphQL`. The directive will have the following arguments:
* `operations`: An array containing the oprations in which this callback will be executed and the result returned, possible values are `CREATE` and `UPDATE`.
* `name`: Name of the callback to be executed, note that the name will have to match the named passed to `Neo4jGrapQL`.

The new config option `callbacks` will accept an object with the callbacks to be used:
```typescript
type Neo4jGraphQLCallback<T extends string | number | Date | boolean> = (args: Record<string, any>) => T | undefined | null | Promise<T | undefined | null>;
type Neo4jGraphQLCallbacks = Record<string, Neo4jGraphQLCallback>
```

When executed, callbacks results **must** be appropriately validated at runtime, to ensure the types match the expected GraphQL type. Callbacks may return 
a Promise.

For non-required values, callbacks may return `undefined` (meaning that nothing will be changed or added to the property) or `null` (meaning that the property 
will be removed). All of this needs to be validated at runtime.

The callback will receive the rest of the arguments passed to the mutation.

### Related properties

> WIP

### Usage Examples

#### Custom ID
Some users whant to use different generated ids (e.g. [nanoid](https://www.npmjs.com/package/nanoid)) when creating nodes. 
An autogenerated property `id` with a callback based on this library could solve this problem:

```graphql
type Product implements @node {
    id: ID! @callback(operations: [CREATE], name: "nanoid")
    name: String
}
```

The following signature would be used to create these ids:

```typescript
const nanoid = async (args) => {
  return nanoid();
}

const neoSchema = new Neo4jGraphQL({
    typeDefs,
    config: {
        callbacks: {
            nanoid: nanoid,
        },
    },
});
```

#### Slugs
Another common use case, is to automatically generate [slugs](https://en.wikipedia.org/wiki/Clean_URL#Slug) from a name. For this case is important 
to keep consistency between the 2 values if the first is changed:


```graphql
type Product implements @node {
    name: String
    slug: @callback(operations: [CREATE, UPDATE], name: "slug")
}
```

The following signature would be used to create these ids:

```typescript
const slug = async (product) => {
  return product.name.toLowerCase().replace(/ /g, "-").replace(/[^\w-]+/g,'')
}

const neoSchema = new Neo4jGraphQL({
    typeDefs,
    config: {
        callbacks: {
            slug: slug,
        },
    },
});
```

> Note that unlike [`@computed`](https://neo4j.com/docs/graphql-manual/current/custom-resolvers/#custom-resolvers-computed). 
These properties will be stored in the database.

## Risks

* Some directive combinations (e.g. `@default` with `@callback`) may be invalid.
* Relationship properties
* Type validation

### Security consideration

For security purposes, the result of the callback **must** be escaped, to avoid Cypher Injection

## Out of Scope

N/A
