import type { GraphQLResolveInfo } from "graphql";
import type { ConcreteEntity } from "../../schema-model/entity/ConcreteEntity";
import type { Neo4jGraphQLComposedContext } from "../../schema/resolvers/composition/wrap-query-and-mutation";
import type { Neo4jGraphQLTranslationContext } from "../../types/neo4j-graphql-translation-context";
import { execute } from "../../utils";
import getNeo4jResolveTree from "../../utils/get-neo4j-resolve-tree";
import { translateReadOperation } from "../translators/translate-read-operation";

export function generateReadResolver({ entity }: { entity: ConcreteEntity }) {
    async function resolve(_root: any, args: any, context: Neo4jGraphQLComposedContext, info: GraphQLResolveInfo) {
        const resolveTree = getNeo4jResolveTree(info, { args });

        (context as Neo4jGraphQLTranslationContext).resolveTree = resolveTree;
        // for composite entities we don't use "this" as varName but we use an autogenerated variable

        const { cypher, params } = translateReadOperation({
            context: context as Neo4jGraphQLTranslationContext,
            entity,
        });
        const executeResult = await execute({
            cypher,
            params,
            defaultAccessMode: "READ",
            context,
            info,
        });

        return executeResult.records.map((x) => x.this);
    }

    return resolve;
}
