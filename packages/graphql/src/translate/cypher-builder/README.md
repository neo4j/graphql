# Cypher Builder

This is an internal utility to build Cypher queries, part of `@neo4j/graphql`. This is only intended for internal usage and it is **not** feature complete.

> Note that this is still under development.

## Basic Example

```typescript
const idParam = new CypherBuilder.Param("my-id"); // Defines a new parameter to be passed to the query
const movieNode = new CypherBuilder.Node({
    labels: ["Movie"],
});

const createQuery = new CypherBuilder.Create(movieNode, { test: new CypherBuilder.Param("test-value") })
    .set({ id: idParam })
    .return(movieNode); // CREATE statement to create the given node, with a SET

const { cypher, params } = createQuery.build(); // Compiles the cypher and paramenters
```

In this example, `cypher` will be a string containing the following:

```cypher
CREATE (this0:\`Movie\` { test: $param0 })  # Create statement, this0 is an autogenerated variable for the node
SET this0.id = $param1 # Set second parameter
RETURN this0
```

`params` will contain the parameters used in that query as an object:

```typescript
{
    "param0": "test-value",
    "param1": "my-id",
}
```

## Nodes

New nodes can be defined with `new CypherBuilder.Node`:

```typescript
const movieNode = new CypherBuilder.Node({
    labels: ["Movie"],
});
```

This will create a new reference to a `Movie` node and match pattern of the form:

```cypher
(this0:\`Movie\`)
```

Nodes can be used to build statements (see below). The same node can be used on multiple statements, this will ensure the correct references
are used.

## Relationship

Like Nodes, relationships can be defined and used as references in statement later. To define a relationship you must also define the related nodes:

```typescript
const node1 = new CypherBuilder.Node({
    labels: ["Movie"],
});
const node2 = new CypherBuilder.Node({
    labels: ["Actor"],
});

const relationship = new CypherBuilder.Relationship({
    source: node1,
    target: node2,
    type: "ACTED_IN",
});
```

This can be used in statements to define relationship patterns.

## Parameters

Parameters need to be defined with the class `new CypherBuilder.Param`, this is to allow reuse, keeping track of them, and avoid naming collisions:

```typescript
const nameParam = new CypherBuilder.Param("Matrix");

const matchQuery1 = new CypherBuilder.Match(node1, { test: nameParam });
const matchQuery2 = new CypherBuilder.Match(node2, { test: nameParam });
```

In the previous example, 2 different nodes share the same parameter, when the Cypher is compiled, it will look something like:

```cypher
(node1:Movie {name: $param0})
...
(node2:Movie {name:$param0})
```

A single param will be passed to the driver:

```json
{
    "param0": "Matrix"
}
```

## Statements

Statements do the bulk of the query generation and composition, all statements are build into an AST, which, at compile time (`.build()`) will
traverse the tree, create all the parameters and variables, and compose both, the cypher string and the paramters object.

Each statement will take its own parameters, and will allow for different methods, some will take other statements, allowing for composition.

## Match

Constructs `MATCH` statements with filters and return:

```typescript
const idParam = new CypherBuilder.Param("my-id");
const movieNode = new CypherBuilder.Node({
    labels: ["Movie"],
});

const matchQuery = new CypherBuilder.Match(movieNode, { test: new CypherBuilder.Param("test-value") })
    .where(movieNode, { id: idParam })
    .return(movieNode);
```

This will return:

```cypher
MATCH (this0:\`Movie\` { test: $param0 })
WHERE this0.id = $param1
RETURN this0
```

Note that parameters may be passed to the matching pattern, in the constructor, or as part of the `where` statement.
In the where statement, parameters can be set to match any variable

### Relationships

To be implemented

## Create

The create statement allow to create and return both, **Nodes** and **Relationships**:

A single node can be created, and its parameters set:

```typescript
const idParam = new CypherBuilder.Param("my-id");
const movieNode = new CypherBuilder.Node({
    labels: ["Movie"],
});

const createQuery = new CypherBuilder.Create(movieNode).set({ id: idParam }).return(movieNode);
```

This will generate:

```
CREATE (this0:\`Movie\`)
SET this0.id = $param1
RETURN this0
```

### Relationships

To be implemented

## Merge

Generates a `MERGE ... ON CREATE ...` statement, it can be used with a single node or a relationship:

### Node

```typescript
const node1 = new CypherBuilder.Node({
    labels: ["MyLabel"],
});

const query = new CypherBuilder.Merge(node1).onCreate({
    source: {
        age: new CypherBuilder.Param(23),
        name: new CypherBuilder.Param("Keanu"),
    },
});
```

The generated Cypher would look like:

```cypher
MERGE (this1)
ON CREATE SET
        this1.age = $param0,
        this1.name = $param1,
```

### Relationship

```typescript
const node1 = new CypherBuilder.Node({
    labels: ["MyLabel"],
});
const node2 = new CypherBuilder.Node({});

const relationship = new CypherBuilder.Relationship({ source: node1, target: node2 });

const query = new CypherBuilder.Merge(relationship).onCreate({
    source: {
        age: new CypherBuilder.Param(23),
        name: new CypherBuilder.Param("Keanu"),
    },
    relationship: {
        screentime: new CypherBuilder.Param(10),
    },
});
```

The generated Cypher would look like:

```cypher
MERGE (this1)-[this0]->(this2)
ON CREATE SET
        this1.age = $param0,
        this1.name = $param1,
        this0.screentime = $param2
```

Note that in this case, the match patter will **only** use the variable name. Full match pattern with merge is not yet supported.
As before, match parameters can be passed as second argument in the contructor.

## Call

Call takes a Cypher statement, and wraps it in a `CALL { }` block:

```typescript
const idParam = new CypherBuilder.Param("my-id");
const movieNode = new CypherBuilder.Node({
    labels: ["Movie"],
});

const createQuery = new CypherBuilder.Create(movieNode, { id: idParam }).return(movieNode); // CREATE ... RETURN statement

const queryResult = new CypherBuilder.Call(createQuery).build();
```

```cypher
CALL {
    CREATE (this0:\`Movie\`)
    SET this0.id = $param0
    RETURN this0
    RETURN COUNT(*) AS _
}
```

## Query

Query is a dummy statement, used to concatenate multiple statements.

## Apoc

All apoc statements are under `CypherBuilder.Apoc`

### Validate

Generates an `apoc.validate` statement

```typescript
const query = new CypherBuilder.Apoc.Validate({
    predicate: `NOT(my_statement)`,
    message: AUTH_FORBIDDEN_ERROR,
});
```

## Design decisions

Some decisions were taking during the design and implementation of the cypher builder, some will be explained here to avoid confusion.
Other decisions can be consulted in the [original rfc](docs/rfcs/rfc-010-cypher-builder.md)

### Node and Relationship classes

A naive implementation of a builder could define statements as follow:

```typescript
new CypherBuilder.Create({ label: "node" });
```

This is slightly less verbose, and arguably more readable. However, due to the lack of references to the created node, it is hard to compose into
more complex queries, for instance, if we want to create 2 nodes but only return 1.

The only way of holding a reference with this approach, would be by defining the variable itself:

```typescript
new CypherBuilder.Create({ label: "node", variable: "this0" });

new CypherBuilder.Return("this0");
```

However, this quickly lead to naming collisions, and high complexity, as variables need to be defined along the queries, instead of lazily. (See Cypher Context)

### Parameters

Following the same logic as before, by having a class `Param`, these can be tracked, reused, and named lazily

### Cypher Context

Cypher context is an internal class, used to track references to variables and parameters at build time.

## Further work

-   Improvements to the Node and Relationship classes to spearate the concept of `variables` (this0) and "MatchPatterns" (`(this0:Movie {...})`)
-   MATCH, UNION and projections
-   Improve unit testing
