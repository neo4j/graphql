/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { Expr, Map, MapProjection } from "@neo4j/cypher-builder";
import Cypher from "@neo4j/cypher-builder";
import type { Node, Relationship } from "../../../classes";
import type { CallbackBucket } from "../../../classes/CallbackBucket";
import type { PredicateReturn } from "../../../types";
import type { Neo4jGraphQLTranslationContext } from "../../../types/neo4j-graphql-translation-context";
import { getCypherRelationshipDirection } from "../../../utils/get-relationship-direction";
import mapToDbProperty from "../../../utils/map-to-db-property";
import { filterTruthy } from "../../../utils/utils";
import { checkAuthentication } from "../../authorization/check-authentication";
import {
    createAuthorizationAfterPredicate,
    createAuthorizationAfterPredicateField,
} from "../../authorization/create-authorization-after-predicate";
import createRelationshipValidationString from "../../create-relationship-validation-string";
import type { CreateAST, NestedCreateAST, UnwindASTNode, Visitor } from "../GraphQLInputAST/GraphQLInputAST";

type UnwindCreateScopeDefinition = {
    unwindVar: Cypher.Variable;
    parentVar: Cypher.Variable;
};
type GraphQLInputASTNodeRef = string;
type UnwindCreateEnvironment = Record<GraphQLInputASTNodeRef, UnwindCreateScopeDefinition>;

export class UnwindCreateVisitor implements Visitor<Cypher.Clause> {
    unwindVar: Cypher.Variable;
    callbackBucket: CallbackBucket;
    context: Neo4jGraphQLTranslationContext;
    rootNode: Cypher.Node | undefined;
    clause: Cypher.Clause | undefined;
    environment: UnwindCreateEnvironment;

    constructor(unwindVar: Cypher.Variable, callbackBucket: CallbackBucket, context: Neo4jGraphQLTranslationContext) {
        this.unwindVar = unwindVar;
        this.callbackBucket = callbackBucket;
        this.context = context;
        this.environment = {};
    }

    public visitChildren(
        currentASTNode: UnwindASTNode,
        unwindVar: Cypher.Variable,
        parentVar: Cypher.Variable
    ): Cypher.Clause[] {
        if (currentASTNode.children) {
            const scope = { unwindVar, parentVar };
            const childrenRefs = currentASTNode.children.map((children) => {
                this.environment[children.id] = scope;
                return children.accept(this);
            });
            return childrenRefs;
        }
        return [];
    }

    public visitCreate(create: CreateAST): Cypher.Clause {
        const labels = create.node.getLabels(this.context);
        const currentNode = new Cypher.Node();

        const nestedClauses = this.visitChildren(create, this.unwindVar, currentNode);

        const setProperties = create.nodeProperties.map((property: string) =>
            fieldToSetParam(create.node, currentNode, property, this.unwindVar.property(property))
        );
        const autogeneratedProperties = getAutoGeneratedFields(create.node, currentNode);

        const createClause = new Cypher.Create(new Cypher.Pattern(currentNode, { labels })).set(
            ...setProperties,
            ...autogeneratedProperties
        );

        const relationshipValidationClause = new Cypher.Raw((env: Cypher.Environment) => {
            const validationStr = createRelationshipValidationString({
                node: create.node,
                context: this.context,
                varName: env.getReferenceId(currentNode),
            });
            const cypher: string[] = [];

            if (validationStr) {
                cypher.push(`WITH ${env.getReferenceId(currentNode)}`);
                cypher.push(validationStr);
            }
            return cypher.join("\n");
        });

        checkAuthentication({ context: this.context, node: create.node, targetOperations: ["CREATE"] });
        const authNodeClause = this.getAuthNodeClause(create.node, this.context, currentNode);

        let authorizationFieldsClause: Cypher.CompositeClause | Cypher.With | undefined;

        const authorizationPredicateReturn = this.getAuthorizationFieldClause({
            astNode: create,
            nodeRef: currentNode,
            unwindVar: this.unwindVar,
        });
        if (authorizationPredicateReturn) {
            const { predicate, preComputedSubqueries } = authorizationPredicateReturn;

            if (predicate) {
                if (preComputedSubqueries && !preComputedSubqueries.empty) {
                    authorizationFieldsClause = Cypher.concat(
                        new Cypher.With("*"),
                        preComputedSubqueries,
                        new Cypher.With("*").where(predicate)
                    );
                }

                authorizationFieldsClause = new Cypher.With("*").where(predicate);
            }
        }

        const clause = Cypher.concat(
            ...filterTruthy([
                createClause,
                ...nestedClauses,
                authNodeClause,
                authorizationFieldsClause,
                relationshipValidationClause,
                new Cypher.Return(currentNode),
            ])
        );
        this.rootNode = currentNode;
        this.clause = new Cypher.Call(clause).importWith(this.unwindVar);
        return this.clause;
    }

    public visitNestedCreate(nestedCreate: NestedCreateAST): Cypher.Clause {
        const scope = this.getScope(nestedCreate.id);

        const parentVar = scope.parentVar;
        const unwindVar = scope.unwindVar;
        const { node, relationship, relationshipPropertyPath } = nestedCreate;
        const blockWith = new Cypher.With(parentVar, unwindVar);
        const createUnwindVar = new Cypher.Variable();
        const createUnwindClause = new Cypher.Unwind([
            unwindVar.property(relationshipPropertyPath).property("create"),
            createUnwindVar,
        ]);

        const labels = node.getLabels(this.context);
        const currentNode = new Cypher.Node();
        const nodeVar = new Cypher.Variable();
        const edgeVar = new Cypher.Variable();
        const withCreate = new Cypher.With(
            [createUnwindVar.property("node"), nodeVar],
            [createUnwindVar.property("edge"), edgeVar],
            parentVar
        );

        const nestedClauses = this.visitChildren(nestedCreate, nodeVar, currentNode);

        const createClause = new Cypher.Create(new Cypher.Pattern(currentNode, { labels }));
        const relationField = relationship[0];
        if (!relationField) throw new Error("Transpile error: No relationship found");

        const relationshipVar = new Cypher.Relationship();

        const direction = getCypherRelationshipDirection(relationField);

        const relationshipPattern = new Cypher.Pattern(parentVar as Cypher.Node)
            .related(relationshipVar, { direction, type: relationField.type })
            .to(currentNode);

        const mergeClause = new Cypher.Merge(relationshipPattern);

        const setPropertiesNode = nestedCreate.nodeProperties.map((property: string) =>
            fieldToSetParam(node, currentNode, property, nodeVar.property(property))
        );
        const autogeneratedProperties = getAutoGeneratedFields(node, currentNode);

        createClause.set(...setPropertiesNode, ...autogeneratedProperties);
        if (nestedCreate.edgeProperties && nestedCreate.edgeProperties.length && nestedCreate.edge) {
            const setPropertiesEdge = nestedCreate.edgeProperties
                .map((property) => {
                    if (nestedCreate.edge) {
                        return fieldToSetParam(
                            nestedCreate.edge,
                            relationshipVar,
                            property,
                            edgeVar.property(property)
                        );
                    }
                })
                .filter((v): v is Cypher.SetParam => !!v);
            const autogeneratedEdgeProperties = getAutoGeneratedFields(nestedCreate.edge, relationshipVar);
            mergeClause.set(...setPropertiesEdge, ...autogeneratedEdgeProperties);
        }

        const subQueryStatements: Cypher.Clause[] = [
            blockWith,
            createUnwindClause,
            withCreate,
            createClause,
            mergeClause,
        ];
        const relationshipValidationClause = new Cypher.Raw((env: Cypher.Environment) => {
            const validationStr = createRelationshipValidationString({
                node,
                context: this.context,
                varName: env.getReferenceId(currentNode),
            });
            const cypher: string[] = [];
            if (validationStr) {
                cypher.push(`WITH ${env.getReferenceId(currentNode)}`);
                cypher.push(validationStr);
            }
            return cypher.join("\n");
        });

        checkAuthentication({ context: this.context, node: nestedCreate.node, targetOperations: ["CREATE"] });
        const authNodeClause = this.getAuthNodeClause(nestedCreate.node, this.context, currentNode);

        let authorizationFieldsClause: Cypher.CompositeClause | Cypher.With | undefined;

        const authorizationPredicateReturn = this.getAuthorizationFieldClause({
            astNode: nestedCreate,
            nodeRef: currentNode,
            unwindVar: nodeVar,
        });
        if (authorizationPredicateReturn) {
            const { predicate, preComputedSubqueries } = authorizationPredicateReturn;

            if (predicate) {
                if (preComputedSubqueries && !preComputedSubqueries.empty) {
                    authorizationFieldsClause = Cypher.concat(
                        new Cypher.With("*"),
                        preComputedSubqueries,
                        new Cypher.With("*").where(predicate)
                    );
                }

                authorizationFieldsClause = new Cypher.With("*").where(predicate);
            }
        }

        subQueryStatements.push(...nestedClauses);
        if (authNodeClause) {
            subQueryStatements.push(authNodeClause);
        }
        if (authorizationFieldsClause) {
            subQueryStatements.push(authorizationFieldsClause);
        }

        subQueryStatements.push(relationshipValidationClause);
        subQueryStatements.push(new Cypher.Return([Cypher.collect(Cypher.Null), new Cypher.Variable()]));
        const subQuery = Cypher.concat(...subQueryStatements);
        const callClause = new Cypher.Call(subQuery);
        const outsideWith = new Cypher.With(parentVar, unwindVar);

        return Cypher.concat(outsideWith, callClause);
    }

    private getAuthNodeClause(
        node: Node,
        context: Neo4jGraphQLTranslationContext,
        nodeRef: Cypher.Node
    ): Cypher.Clause | undefined {
        const authorizationPredicateReturn = createAuthorizationAfterPredicate({
            context,
            nodes: [
                {
                    variable: nodeRef,
                    node,
                },
            ],
            operations: ["CREATE"],
        });

        if (authorizationPredicateReturn) {
            const { predicate, preComputedSubqueries } = authorizationPredicateReturn;

            if (predicate) {
                if (preComputedSubqueries && !preComputedSubqueries.empty) {
                    return Cypher.concat(
                        new Cypher.With("*"),
                        preComputedSubqueries,
                        new Cypher.With("*").where(predicate)
                    );
                }

                return new Cypher.With("*").where(predicate);
            }
        }
    }

    private getAuthorizationFieldClause({
        astNode,
        nodeRef,
        unwindVar,
    }: {
        astNode: CreateAST | NestedCreateAST;
        nodeRef: Cypher.Node;
        unwindVar: Cypher.Variable;
    }): PredicateReturn | undefined {
        const authorizationPredicates: Cypher.Predicate[] = [];
        let authorizationSubquery: Cypher.CompositeClause | undefined = undefined;

        const usedAuthFields = astNode.nodeProperties
            .flatMap((property) => {
                return astNode.node.primitiveFields.filter((authField) => authField.fieldName === property);
            })
            .filter((n) => n);

        for (const field of usedAuthFields) {
            checkAuthentication({
                context: this.context,
                node: astNode.node,
                targetOperations: ["CREATE"],
                field: field.fieldName,
            });
            const authorizationPredicateReturn = createAuthorizationAfterPredicateField({
                context: this.context,
                nodes: [
                    {
                        variable: nodeRef,
                        node: astNode.node,
                        fieldName: field.fieldName,
                    },
                ],
                operations: ["CREATE"],
                conditionForEvaluation: Cypher.isNotNull(unwindVar.property(field.fieldName)),
            });
            if (authorizationPredicateReturn) {
                const { predicate, preComputedSubqueries } = authorizationPredicateReturn;
                if (predicate) {
                    if (preComputedSubqueries && !preComputedSubqueries.empty) {
                        authorizationSubquery = Cypher.concat(authorizationSubquery, preComputedSubqueries);
                    }
                    authorizationPredicates.push(predicate);
                }
            }
        }

        return {
            predicate: Cypher.and(...authorizationPredicates),
            preComputedSubqueries: authorizationSubquery,
        };
    }

    public getScope(identifier: number): UnwindCreateScopeDefinition {
        const scope = this.environment[identifier];
        if (!scope) {
            throw new Error("Transpile error: No scope found");
        }
        return scope;
    }

    /*
     * Returns the Cypher Reference of the root Nodes and the Cypher Clause generated
     */
    public build(): [Cypher.Node?, Cypher.Clause?] {
        return [this.rootNode, this.clause];
    }
}

function getAutoGeneratedFields(
    graphQLElement: Node | Relationship,
    cypherNodeRef: Cypher.Node | Cypher.Relationship
): Cypher.SetParam[] {
    const setParams: Cypher.SetParam[] = [];
    const timestampedFields = graphQLElement.temporalFields.filter(
        (x) => ["DateTime", "Time"].includes(x.typeMeta.name) && x.timestamps?.includes("CREATE")
    );
    timestampedFields.forEach((field) => {
        // DateTime -> datetime(); Time -> time()
        const relatedCypherExpression = Cypher[field.typeMeta.name.toLowerCase()]();
        if (field.dbPropertyName) {
            setParams.push([cypherNodeRef.property(field.dbPropertyName), relatedCypherExpression]);
        }
    });

    const autogeneratedIdFields = graphQLElement.primitiveFields.filter((x) => x.autogenerate);
    autogeneratedIdFields.forEach((field) => {
        if (field.dbPropertyName) {
            setParams.push([cypherNodeRef.property(field.dbPropertyName), Cypher.randomUUID()]);
        }
    });
    return setParams;
}

function fieldToSetParam(
    graphQLElement: Node | Relationship,
    cypherNodeRef: Cypher.Node | Cypher.Relationship,
    key: string,
    value: Exclude<Expr, Map | MapProjection>
): Cypher.SetParam {
    const pointField = graphQLElement.pointFields.find((x) => key === x.fieldName);
    const dbName = mapToDbProperty(graphQLElement, key);
    if (pointField) {
        if (pointField.typeMeta.array) {
            const comprehensionVar = new Cypher.Variable();
            const mapPoint = Cypher.point(comprehensionVar);
            const expression = new Cypher.ListComprehension(comprehensionVar, value).map(mapPoint);
            return [cypherNodeRef.property(dbName), expression];
        }
        return [cypherNodeRef.property(dbName), Cypher.point(value)];
    }
    return [cypherNodeRef.property(dbName), value];
}
