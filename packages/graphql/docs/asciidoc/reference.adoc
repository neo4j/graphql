[[reference]]
= Reference

This is the reference documentation for @neo4j/graphql.
It covers the programming model, APIs, concepts, annotations and technical details of the library.

This document is split into zones;

. Setup - Importable functions and classes
. Schema - Defining your GraphQL Schema
. Querying - Interacting with the generated schema
. Developer Notes - Some tips, pointers and gotchas pointed out


== Setup

Importable functions and classes.


=== `makeAugmentedSchema`

Main Entry to the library.
Use to construct an instance of `NeoSchema`.

[source, javascript]
----
const { makeAugmentedSchema } = require("@neo4j/graphql");

const neoSchema = makeAugmentedSchema({
    typeDefs,
    resolvers?,
    schemaDirectives?,
    debug?,
});
----


=== Implementing Custom Resolvers

This library will auto-generate resolvers for queries and mutations, you don't need to implement resolvers yourself, however if you have some custom code you can specify custom resolvers.


==== Custom Field Resolver

[source, javascript]
----
const typeDefs = `
    type User {
        userId: ID!
        firstName: String
        lastName: String
        fullName: String
    }
`;

const resolvers = {
    User: {
        fullName(root, params, ctx, resolveInfo) {
            return `${root.firstName} ${root.lastName}`;
        },
    },
};

const schema = makeAugmentedSchema({
    typeDefs,
    resolvers,
});
----


==== Custom Query Resolver

--
Same applies for Mutations and Subscriptions
--

[source, javascript]
----
const typeDefs = `
    type User {
        userId: ID!
    }

    type Query {
        users: [User]
    }
`;

const resolvers = {
    Query: {
        users: () => // do some logic
    }
};

const schema = makeAugmentedSchema({
    typeDefs,
    resolvers,
});
----


=== `NeoSchema`

Core class of the library.
Holds all metadata about schema plus access to the OGM.

[source, javascript]
----
const neo4j = require("neo4j-driver");
const { makeAugmentedSchema } = require("@neo4j/graphql");
const { ApolloServer } = require("apollo-server");

const driver = neo4j.driver(
    config.NEO_URL,
    neo4j.auth.basic("admin", "password")
);

const neoSchema = makeAugmentedSchema({
    typeDefs,
    resolvers?,
    context?,
    schemaDirectives?,
    debug?,
});

const apolloServer = new ApolloServer({
    schema: neoSchema.schema,
    context: ({ req }) => ({ req, driver })
});
----

> Notice `context` driver injection

=== OGM
Common applications won't just expose a single API. On the same instance as the GraphQL API there may be; scheduled jobs, authentication, migrations and not to forget any custom logic in the resolvers themselves. We expose a OGM(Object Graph Model) on top of the pre-existing GraphQL work and abstractions. Generate your normal GraphQL schema & use the exposed .model method to receive an instance of a model. 

[source, javascript]
----
import { OGM } from "@neo4j/graphql";
import * as neo4j from "neo4j-driver";

const typeDefs = `
    type Movie {
        id: ID
        name: String
    }
`;

const driver = neo4j.driver("bolt://localhost:7687", neo4j.auth.basic("admin", "password"));

const ogm = new OGM({ typeDefs, driver });

const Movie = ogm.model("Movie");

const [theMatrix] = await Movie.find({ where: { name: "The Matrix" } });
----

You can call the following on the model;

. find
. create
. delete
. update

Each method maps to the underlying generated Query or Mutation for that Model.

==== `@private`
The `@private` directive allows you to specify fields that should only be accessible through the OGM. This is very handy as you can hide fields such as user password to the outside world. Simply put the @private directive on the field you wish to be inaccessible through the exposed API;

[source, graphql]
----
type User {
    username: String!
    email: String!
    password: String! @private
}
----

Using the password field is a great example here. In your application, you would want to hash passwords & hide them from snoopers. You could have a custom resolver, using the OGM, to update and set passwords. This is more apparent when you want to use the same type definitions to drive a public-facing schema and an OGM;

[source, javascript]
----
import { makeAugmentedSchema, OGM } from "@neo4j/graphql";
import * as neo4j from "neo4j-driver";

const driver = neo4j.driver(
    "bolt://localhost:7687",
    neo4j.auth.basic("admin", "password")
);

const typeDefs = `
    type User {
        username: String!
        email: String!
        password: String! @private
    }
`;

// public without password 
const neoSchema = makeAugmentedSchema({ typeDefs, context: { driver } });

// private with access to password
const ogm = new OGM({ typeDefs, driver });

const apolloServer = new ApolloServer({ schema: neoSchema.schema });
----

We also exclude the following directives from OGM generation;

1. `@auth`
2. `@exclude`

==== Selection Set 
This is a GraphQL specific term. When you preform a query you have the operation;

[source, graphql]
----
query {
    myOperation
}
----

And you also have a Selection Set;

[source, graphql]
----
query {
    myOperation {
        # Selection Set start
        id
        name
    } # Selection Set end
}
----

When using the OGM we do not want users providing a selections sets... Doing so would make the OGM feel more like querying the GraphQL Schema when the OGM is designed as an abstraction ontop of it. To combat this we do Autogenerated Selection Sets. Given a Node;

[source, graphql]
----
type Node {
    id: ID
    name: String
    relation: [Node] @relationship(...)
    customCypher: [Node] @cypher(...)
}
----

We pre-generate a pre-defined selection set. We don't include any relationships or cypher fields, as they could be computationally expensive. Given the above Node the auto pre-defined selection set would be;

[source, graphql]
----
{
    id
    name
}
----

This means that by default, querying for Node(s), you would only get the `.id` and `.name` properties returned. If you want to select more you can either define a selection set at execution time or as a static on the Model;

=====  Selection set at execution time

[source, javascript]
----
import { OGM } from "@neo4j/graphql";
import * as neo4j from "neo4j-driver";

const driver = neo4j.driver(
    "bolt://localhost:7687",
    neo4j.auth.basic("admin", "password")
);

const typeDefs = `
    type Node {
        id: ID
        name: String
        relation: [Node] @relationship(...)
        customCypher: [Node] @cypher(...)
    }
`;

const ogm = new OGM({ typeDefs, driver });
const Node = ogm.model("Node");

const selectionSet = `
    {
        id
        name
        relation {
            id
            name
        }
        customCypher {
            id
            name
        }
    }
`;
const nodes = await Node.find({ selectionSet });
----

=====  Selection set as a static

[source, javascript]
----
import { OGM } from "@neo4j/graphql";
import * as neo4j from "neo4j-driver";

const driver = neo4j.driver(
    "bolt://localhost:7687",
    neo4j.auth.basic("admin", "password")
);

const typeDefs = `
    type Node {
        id: ID
        name: String
        relation: [Node] @relationship(...)
        customCypher: [Node] @cypher(...)
    }
`;

const ogm = new OGM({ typeDefs, driver });
const Node = ogm.model("Node");

const selectionSet = `
    {
        id
        name
        relation {
            id
            name
        }
        customCypher {
            id
            name
        }
    }
`;
Node.setSelectionSet(selectionSet)
----

=== `translate`

Used to translate the `resolveInfo` object of a custom resolver into cypher and params. Only to be used on custom/overridden resolvers. Using this function can act as both a pre and post mechanism for your resolvers.

[source, javascript]
----
const { makeAugmentedSchema, translate } = require("@neo4j/neo4j-graphql");

const typeDefs = `
    type User {
        name: String
    }
`;

const resolvers = {
    Query: {
        users: (root, args, context, resolveInfo) => {
            // pre
            const [cypher, params] = translate({
                context,
                resolveInfo,
            });
            // post
        },
    },
};

const neoSchema = makeAugmentedSchema({ typeDefs, resolvers });
----


== Schema

Defining your GraphQL Schema.

=== Nodes

To represent a node in the GraphQL schema use the `type` definition;

[source, graphql]
----
type Node {
    id: ID
}
----


=== Relationships

To represent a relationship between two nodes use the `@relationship` directive;

[source, graphql]
----
type Node {
    id: ID
    related: [Node] @relationship(type: "RELATED", direction: "OUT")
}
----

=== `@cypher`

GraphQL schema directive that can be used to bind a GraphQL field to the results of a Cypher query.
For example, let's add a field `similarMovies` to our Movie which is bound to a Cypher query to find other movies with an overlap of actors;

[source, graphql]
----
type Actor {
    actorId: ID!
    name: String
    movies: [Movie] @relationship(type: "ACTED_IN", direction: "OUT")
}

type Movie {
    movieId: ID!
    title: String
    description: String
    year: Int
    actors(limit: Int = 10): [Actor]
        @relationship(type: "ACTED_IN", direction: "IN")
    similarMovies(limit: Int = 10): [Movie]
        @cypher(
            statement: """
            MATCH (this)<-[:ACTED_IN]-(:Actor)-[:ACTED_IN]->(rec:Movie)
            WITH rec, COUNT(*) AS score ORDER BY score DESC
            RETURN rec LIMIT $limit
            """
        )
}
----

As well as fields on types you can also define a custom `@cypher` directive on a custom Query or Mutation;

[source, graphql]
----
type Actor {
    actorId: ID!
    name: String
}

type Query {
    allActors: [Actor]
        @cypher(
            statement: """
            MATCH (a:Actor)
            RETURN a
            """
        )
}
----


==== Statement Globals

Global variables available inside the `@cypher` statement.

. `this` - bound to the currently resolved node
. `jwt` - decoded JWT or `{}`

==== Returning from the cypher statement

You must return a single value representing corresponding type;

_Primitives_

[source, graphql]
----
type Query {
    randomNumber: Int @cypher(statement: "RETURN rand()") ## ✅ Supported
}
----

_Nodes_

[source, graphql]
----
type Query {
    users: [User]
        @cypher(
            statement: """
            MATCH (u:User)
            RETURN u
            """
        ) ## ✅ Supported
}
----

_Objects_

[source, graphql]
----
type User {
    id
}

type Query {
    users: [User] @cypher(statement: """
        MATCH (u:User)
        RETURN {
            id: u.id
        }
    """) ## ✅ Supported
}
----

_Multiple Rows_ ❌

[source, graphql]
----
type User {
    id
}

type Query {
    users: [User] @cypher(statement: """
        MATCH (u:User)-[:HAS_POST]->(p:Post)
        RETURN u, p
    """) ## ❌ Not Supported
}
----


=== `@auth`

Once specified it will ‘wrap’ generated Queries & Mutations, interacting with an incoming JWT, adding predicates to the generated cypher.

==== Setup

This implementation only accepts JWT's in the request. You can use ENV `JWT_SECRET` to specificity the JWT secret and use `JWT_NO_VERIFY=true` to disable the verification of the JWT, handy for development. The accepted token type should be Bearer where the header should be authorization.

_Example HTTP Request_

[source]
----
POST / HTTP/1.1
authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJyb2xlcyI6WyJ1c2VyX2FkbWluIiwicG9zdF9hZG1pbiIsImdyb3VwX2FkbWluIl19.IY0LWqgHcjEtOsOw60mqKazhuRFKroSXFQkpCtWpgQI
content-type: application/json
----

⚠ You will need to inject the request object into the context before you can use auth. Here is an example using Apollo Sever.

[source, javascript]
----
const neoSchema = makeAugmentedSchema({});

const server = new ApolloServer({
    schema: neoSchema.schema,
    context: ({ req }) => ({ req }),
});
----


==== Placement

[source]
----
type User @auth() { // ✅ here is fine
    name: String
}
----

[source]
----
type User {
    name: String @auth() // ❌ not here
}
----

[source]
----
type User {
    posts: [Post] @relationship(...) @auth() // ❌ not here
}
----

[source]
----
type User @auth() @auth() { // ⚠ Only the first one will be used
    name: String
}
----


==== `rules`

The only, required, parameter as part of the directive. Each rule allows you to specify the following properties;

[source, ts]
----
rules: {
    operations: ("create" | "read" | "update" | "delete" | "connect" | "disconnect")[];
    roles?: string[];
    isAuthenticated?: boolean
    allow?: any | "*";
    bind?: any | "*";
}[]
----


==== `operations`

Array of either `"create" | "read" | "update" | "delete" | "connect" | "disconnect"` the corresponding `allow`, `bind` and `roles` will be checked on each subsequent operation.

==== `roles`

Array of strings to be checked against the JWT roles.

[source, graphql]
----
type User @auth(rules: [{ operations: ["update"], roles: ["admin"] }]) {
    id: ID
    name: String
}
----


==== `isAuthenticated`

A boolean to specify if the user should have a valid JWT on specified operations. It only really makes sense to have this as true and setting to false is for semantics only;

[source, graphql]
----
type User
    @auth(
        rules: [{ operations: ["create", "update"], isAuthenticated: true }]
    ) {
    id: ID
    name: String
}
----


==== `allow`

`allow` is a map used to compare a property on the incoming JTW against a property on a node. Allow is called before matching a node, this includes updating, deleting and projecting. Given the following `auth` users can only update there own node;

[source, graphql]
----
type User
    @auth(
        rules: [
            {
                operations: ["update"]
                allow: { id: "sub" } ## sub being 'jwt.sub'
            }
        ]
    ) {
    id: ID
    username: String
}
----

You can traverse relationships in the directive to satisfy complex authorization 'questions' such as; "grant update access to all moderators of a post";

[source, graphql]
----
type User {
    id: ID!
    username: String!
}

type Post
    @auth(
        rules: [
            {
                allow: [{ moderator: { id: "sub" } }] # "sub" being "req.jwt.sub"
                operations: ["update"]
            }
        ]
    ) {
    id: ID!
    title: String!
    moderator: User @relationship(type: "MODERATES_POST", direction: "IN")
}
----

=== `@exclude`

This directive can be used to tell `makeAugmentedSchema` to skip the automatic generation of the Query or Mutations for a certain type.


==== `operations`

The only (and required) argument for this directive. Its value must either be an array containing a subset of strings from `["read", "create", "update", "delete"]`, or the string `"*"` if you wish to skip the generation of the Query and all Mutations for a particular type.


==== Examples

To disable Query generation:

[source, graphql]
----
type User @exclude(operations: ["read"]) {
    name: String
}
----

To disable single Mutation generation:

[source, graphql]
----
type User @exclude(operations: ["create"]) {
    name: String
}
----

To disable multiple Mutation generation:

[source, graphql]
----
type User @exclude(operations: ["create", "delete"]) {
    name: String
}
----

To disable all automatic Query and Mutation generation:

[source, graphql]
----
type User @exclude(operations: "*") {
    name: String
}
----

> Exclude will not effect OGM methods.

=== `DateTime`

ISO datetime string stored as a [`datetime`](https://neo4j.com/docs/cypher-manual/current/functions/temporal/#functions-datetime) temporal type.

[source, graphql]
----
type User {
    createdAt: DateTime
}
----

=== Spatial types

`@neo4j/graphql` offers `Point` and `CartesianPoint` types which translate to spatial values stored using [`point`](https://neo4j.com/docs/cypher-manual/current/syntax/spatial) in the database. The use of either of these types in a GraphQL schema will automatically introduce the types needed to run queries and mutations relevant to these spatial types.

==== Querying using spatial values

Queries can be run to find nodes containing a point containing the exact values specified.

[source, graphql]
----
query Users($longitude: Float!, $latitude: Float!) {
    users(where: { location: { longitude: $longitude, latitude: $latitude } }) {
        name
        location {
            longitude
            latitude
        }
    }
}
----

==== Mutating using spatial values

Similarly, spatial values can be used in mutations to create nodes with spatial values.

[source, graphql]
----
mutation CreateUsers($name: String!, $longitude: Float!, $latitude: Float!) {
    createUsers(input: [{ name: $name, location: { longitude: $longitude, latitude: $latitude } }]) {
        users {
            name
            location {
                longitude
                latitude
            }
        }
    }
}
----

==== Advanced filtering using spatial values

Queries can be run to find nodes relative to a distance from the specified point.

For example, the following query will find users whose location is greater than 5000m (5km) away from the specified point.

[source, graphql]
----
query UsersOver5kmAway($longitude: Float!, $latitude: Float!) {
    users(where: { location_GT: { point: { longitude: $longitude, latitude: $latitude }, distance: 5000 } }) {
        name
        location {
            longitude
            latitude
        }
    }
}
----

=== `@autogenerate`

==== ID's 
If the directive is specified and not provided on create will use the [database to generate a uuid](https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-randomuuid).

[source, graphql]
----
type User {
    id: ID! @autogenerate
    username: String!
}
----

==== Timestamps

If you place the `@autogenerate` directive on a DateTime it will, on specified `operations`, append a [`datetime`](https://neo4j.com/docs/cypher-manual/current/functions/temporal/#functions-datetime) property to the node.


[source, graphql]
----
type User {
    id: ID! @autogenerate
    createdAt: DateTime! @autogenerate(operations: ["create"])
    updatedAt: DateTime! @autogenerate(operations: ["update"])
}
----

== Querying

Interacting with the generated schema. For the purposes of this section we will use the following schema;

[source, graphql]
----
type Post {
    id: ID! @autogenerated
    content: String!
    creator: User @relationship(type: "HAS_POST", direction: "IN")
}

type User {
    id: ID! @autogenerate
    name: String
    posts: [Post] @relationship(type: "HAS_POST", direction: "OUT")
}
----

You are highly encouraged to 'spin up' a playground and experiment will the full generated schema. You can also checkout the [TCK test's](https://github.com/neo4j/graphql/tree/master/packages/graphql/tests/tck/tck-test-files) for more a detailed view.


=== Reading

[source, graphql]
----
query {
    users {
        id
        name
    }
}
----

==== Reading with OGM

[source, javascript]
----
const User = ogm.model("User");

const users = await User.find();
----


=== Reading Relationships

[source, graphql]
----
query {
    users {
        posts {
            content
        }
    }
}
----

==== Reading Relationships with OGM

[source, javascript]
----
const User = ogm.model("User");

const selectionSet = `
    {
        posts {
            content
        }
    }
`;

const users = await User.find({
    selectionSet,
});
----

=== Filtering

> Checkout [TCK](https://github.com/neo4j/graphql/blob/master/packages/graphql/tests/tck/tck-test-files/cypher-advanced-filtering.md) for more advanced querying.

Use the `where` argument;

[source, graphql]
----
query {
    users(where: { id: "123" }) {
        id
        name
    }
}
----

=== Filtering Relationships

Use the `where` argument, on the field;

[source, graphql]
----
query {
    users {
        id
        name
        posts(where: { id: "123" }) {
            content
        }
    }
}
----

=== Sorting

Sort using the `options` argument;

[source, graphql]
----
query {
    users(options: { sort: createdAt_DESC }) {
        id
        name
        createdAt
    }
}
----

=== Sorting Relationships

Sort using the `options` argument, on the field;

[source, graphql]
----
query {
    users {
        id
        name
        posts(options: { sort: createdAt_DESC }) {
            content
        }
    }
}
----

=== Limiting

Limit using the `options` argument;

[source, graphql]
----
query {
    users(options: { limit: 10 }) {
        id
        name
        createdAt
    }
}
----

=== Limiting Relationships

Limit using the `options` argument, on the field;

[source, graphql]
----
query {
    users {
        id
        name
        posts(options: { limit: 10 }) {
            content
        }
    }
}
----

=== Skipping

Limit using the `options` argument;

[source, graphql]
----
query {
    users(options: { skip: 10 }) {
        id
        name
        createdAt
    }
}
----

=== Skipping Relationships

Limit using the `options` argument, on the field;

[source, graphql]
----
query {
    users {
        id
        name
        posts(options: { skip: 10 }) {
            content
        }
    }
}
----

=== Creating

[source, graphql]
----
mutation {
    createUsers(input: [{ name: "dan" }]) {
        users {
            id
            name
        }
    }
}
----

==== Creating with OGM

[source, javascript]
----
const User = ogm.model("User");

const { users } = await User.create({ input: [{ name: "dan" }] });
----

=== Creating a relationship (Create Mutation)

[source, graphql]
----
mutation {
    createUsers(
        input: [
            {
                name: "dan"
                posts: { create: [{ content: "cool nested mutations" }] }
            }
        ]
    ) {
        users {
            id
            name
        }
    }
}
----

=== Connecting a relationship (Create Mutation)

[source, graphql]
----
mutation {
    createUsers(
        input: [
            {
                name: "dan"
                posts: {
                    connect: { where: { content: "cool nested mutations" } }
                }
            }
        ]
    ) {
        users {
            id
            name
        }
    }
}
----

=== Updating

[source, graphql]
----
mutation {
    updateUsers(where: { name: "dan" }, update: { name: "dan" }) {
        users {
            id
            name
        }
    }
}
----

==== Updating with OGM

[source, javascript]
----
const User = ogm.model("User");

const { users } = await User.update({
    where: { name: "dan" },
    update: { name: "dan" },
});
----

=== Creating a relationship (Update Mutation)

[source, graphql]
----
mutation {
    updateUsers(
        where: { name: "dan" }
        create: { posts: [{ content: "cool nested mutations" }] }
    ) {
        users {
            id
            name
        }
    }
}
----

=== Connecting a relationship (Update Mutation)

[source, graphql]
----
mutation {
    updateUsers(
        where: { name: "dan" }
        connect: { posts: { where: { content: "cool nested mutations" } } }
    ) {
        users {
            id
            name
        }
    }
}
----

=== Disconnecting a relationship

[source, graphql]
----
mutation {
    updateUsers(
        where: { name: "dan" }
        disconnect: { posts: { where: { content: "cool nested mutations" } } }
    ) {
        users {
            id
            name
        }
    }
}
----

=== Deleting

[source, graphql]
----
mutation {
    deleteUsers(where: { name: "dan" }) {
        nodesDeleted
    }
}
----

==== Deleting with OGM

[source, javascript]
----
const User = ogm.model("User");

await User.delete({
    where: { name: "dan" },
});
----

== Developer notes

Some tips, pointers and gotchas pointed out

=== Large mutations

There is no lie that nested mutations are very powerful. We have to generate complex cypher to provide the abstractions such as `connect` and `disconnect`. Due to the complexity and size of the cypher we generate its not advised to abuse it. Using the Generated GraphQL schema, If you were to attempt the creation of say one hundred nodes and relations at once Neo4j may throw memory errors. This is simply because of the size of the cypher we generate. If you need to do large edits to the graph you may be better using cypher directly, that being said the abstraction's provided should be fine for most use cases.

> If memory issues are a regular occurrence. You can edit the `dbms.memory.heap.max_size` in the DBMS settings

=== Precision Loss

We currently wrap the Int and Float scalars and pass them through to the database accordingly. One caveat here is that Neo4j Integers are 64-bit and JS numbers are only 53-bit, so there's potential precision loss here, not to mention that GraphQL Int's are only 32-bit: http://spec.graphql.org/June2018/#sec-Int. **We only support 32-bit integers because of the GraphQL limit.**
